import type { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { registerAppTool } from "@modelcontextprotocol/ext-apps/server";
import { z } from "zod";
import type Database from "better-sqlite3";
import { writeFileSync, mkdirSync, existsSync } from "fs";
import path from "path";
import { getSession, getLatestSession } from "../db/sessions-schema.js";
import type { UniversalContext } from "../adapters/claude-code.js";

const WIDGET_URI = "ui://agent-memory/dashboard.html";

/** Token budget constants per target agent */
const TOKEN_BUDGETS: Record<string, number> = {
  "claude-code": 200_000,
  "codex": 128_000,
  "gemini": 1_000_000,
  "cursor": 40_000,
};

function buildClaudeLocalMd(ctx: UniversalContext): string {
  const s = ctx.conversation_summary;
  const meta = ctx.metadata;

  const lines = [
    `# Context transferred from ${meta.source_agent} — ${new Date(meta.timestamp).toLocaleString()}`,
    ``,
    `## Session Info`,
    `- **Session ID:** ${meta.session_id}`,
    `- **Project:** ${meta.project_path}`,
    meta.git_branch ? `- **Branch:** ${meta.git_branch}` : null,
    `- **Tokens captured:** ${meta.token_count.toLocaleString()}`,
    ``,
    `## What We Were Doing`,
    `**Objective:** ${s.objective}`,
    ``,
    `**Current state:** ${s.current_state}`,
    ``,
  ];

  if (s.completed_steps.length) {
    lines.push(`## Completed This Session`);
    for (const step of s.completed_steps) lines.push(`- ${step}`);
    lines.push(``);
  }

  if (s.pending_tasks.length) {
    lines.push(`## Pending Tasks (pick up here)`);
    for (const task of s.pending_tasks) lines.push(`- [ ] ${task}`);
    lines.push(``);
  }

  if (s.key_decisions.length) {
    lines.push(`## Key Decisions Made`);
    for (const d of s.key_decisions) lines.push(`- ${d}`);
    lines.push(``);
  }

  if (ctx.file_changes.length) {
    const realFiles = ctx.file_changes.filter(f => f.path && f.action !== "executed");
    const cmds = ctx.file_changes.filter(f => f.action === "executed");
    if (realFiles.length) {
      lines.push(`## Files Changed`);
      for (const f of realFiles) lines.push(`- **${f.action}** \`${f.path}\` — ${f.summary}`);
      lines.push(``);
    }
    if (cmds.length) {
      lines.push(`## Commands Run`);
      for (const c of cmds) lines.push(`- ${c.summary}`);
      lines.push(``);
    }
  }

  lines.push(
    `---`,
    `*This file was generated by Context Bridge. Remove it once the context is no longer needed.*`
  );

  return lines.filter(l => l !== null).join("\n");
}

function buildAgentsMd(ctx: UniversalContext): string {
  const s = ctx.conversation_summary;
  const meta = ctx.metadata;

  const lines = [
    `# Agent Context — transferred from ${meta.source_agent}`,
    ``,
    `## Background`,
    `You are continuing work that was started in ${meta.source_agent}. Here is the full context:`,
    ``,
    `**Project:** ${meta.project_path}`,
    `**Branch:** ${meta.git_branch || "unknown"}`,
    ``,
    `## Primary Objective`,
    s.objective,
    ``,
    `## Current State`,
    s.current_state,
    ``,
  ];

  if (s.completed_steps.length) {
    lines.push(`## Already Done`);
    for (const step of s.completed_steps) lines.push(`- ${step}`);
    lines.push(``);
  }

  if (s.pending_tasks.length) {
    lines.push(`## Your Tasks`);
    for (const task of s.pending_tasks) lines.push(`- ${task}`);
    lines.push(``);
  }

  if (s.key_decisions.length) {
    lines.push(`## Important Decisions (don't re-litigate these)`);
    for (const d of s.key_decisions) lines.push(`- ${d}`);
    lines.push(``);
  }

  if (ctx.file_changes.length) {
    const realFiles = ctx.file_changes.filter(f => f.path && f.action !== "executed");
    if (realFiles.length) {
      lines.push(`## Modified Files`);
      for (const f of realFiles) lines.push(`- \`${f.path}\` (${f.action})`);
      lines.push(``);
    }
  }

  lines.push(`---`);
  lines.push(`*Generated by Context Bridge. Do not delete until work is complete.*`);

  return lines.join("\n");
}

function buildGeminiMd(ctx: UniversalContext): string {
  return buildClaudeLocalMd(ctx).replace(
    /# Context transferred from .*/,
    `# GEMINI.md — Context from ${ctx.metadata.source_agent}`
  );
}

function buildCursorMdc(ctx: UniversalContext): string {
  const s = ctx.conversation_summary;
  return [
    `---`,
    `description: "Transferred context from ${ctx.metadata.source_agent}"`,
    `alwaysApply: true`,
    `---`,
    ``,
    `# Context Bridge`,
    ``,
    `**Objective:** ${s.objective}`,
    ``,
    `**State:** ${s.current_state}`,
    ``,
    s.pending_tasks.length ? `**Pending:**\n${s.pending_tasks.map(t => `- ${t}`).join("\n")}` : "",
    s.key_decisions.length ? `\n**Decisions:**\n${s.key_decisions.map(d => `- ${d}`).join("\n")}` : "",
  ]
    .filter(l => l !== "")
    .join("\n");
}

export function registerLoadContextTool(server: McpServer, db: Database.Database): void {
  registerAppTool(
    server,
    "load-context",
    {
      description:
        "Load a previously saved session context into the current AI tool. " +
        "Writes a context file (CLAUDE.local.md, AGENTS.md, etc.) in the project directory " +
        "so the target AI immediately understands what was worked on before.",
      inputSchema: {
        session_id: z
          .string()
          .optional()
          .describe("Session ID to load. Defaults to the most recently saved session."),
        target_agent: z
          .enum(["claude-code", "codex", "gemini", "cursor"])
          .optional()
          .default("claude-code")
          .describe("Which AI tool to generate the context file for."),
        output_path: z
          .string()
          .optional()
          .describe(
            "Directory to write the context file to. Defaults to the project path from the saved session."
          ),
      },
      _meta: { ui: { resourceUri: WIDGET_URI } },
    },
    async (params) => {
      try {
        const target = params.target_agent ?? "claude-code";

        const row = params.session_id
          ? getSession(db, params.session_id)
          : getLatestSession(db);

        if (!row) {
          return {
            content: [
              {
                type: "text",
                text: params.session_id
                  ? `No session found with ID: ${params.session_id}`
                  : "No saved sessions found. Run save-context first.",
              },
            ],
            isError: true,
          };
        }

        const ctx: UniversalContext = row.raw_context
          ? JSON.parse(row.raw_context)
          : {
              metadata: {
                source_agent: row.source_agent,
                session_id: row.session_id,
                timestamp: row.captured_at,
                token_count: row.token_count,
                project_path: row.project_path ?? process.cwd(),
                git_branch: row.git_branch ?? undefined,
              },
              conversation_summary: {
                objective: row.objective ?? "",
                completed_steps: JSON.parse(row.completed_steps ?? "[]"),
                current_state: row.current_state ?? "",
                pending_tasks: JSON.parse(row.pending_tasks ?? "[]"),
                key_decisions: JSON.parse(row.key_decisions ?? "[]"),
              },
              file_changes: JSON.parse(row.file_changes ?? "[]"),
              raw_turns: [],
            };

        const outputDir = params.output_path ?? ctx.metadata.project_path ?? process.cwd();
        if (!existsSync(outputDir)) {
          return {
            content: [{ type: "text", text: `Output directory does not exist: ${outputDir}` }],
            isError: true,
          };
        }

        let filename: string;
        let content: string;

        switch (target) {
          case "codex":
            filename = "AGENTS.md";
            content = buildAgentsMd(ctx);
            break;
          case "gemini":
            filename = "GEMINI.md";
            content = buildGeminiMd(ctx);
            break;
          case "cursor": {
            const cursorDir = path.join(outputDir, ".cursor", "rules");
            if (!existsSync(cursorDir)) mkdirSync(cursorDir, { recursive: true });
            filename = path.join(".cursor", "rules", "context-transfer.mdc");
            content = buildCursorMdc(ctx);
            writeFileSync(path.join(outputDir, filename), content, "utf-8");
            break;
          }
          case "claude-code":
          default:
            filename = "CLAUDE.local.md";
            content = buildClaudeLocalMd(ctx);
            break;
        }

        if (target !== "cursor") {
          writeFileSync(path.join(outputDir, filename), content, "utf-8");
        }

        const budget = TOKEN_BUDGETS[target] ?? 128_000;
        const transferPct = Math.min(100, Math.round((ctx.metadata.token_count / budget) * 100));

        const result = [
          `✓ Context loaded for ${target}`,
          `  Written:   ${path.join(outputDir, filename)}`,
          `  From:      ${ctx.metadata.source_agent} session ${ctx.metadata.session_id.slice(0, 8)}…`,
          `  Project:   ${ctx.metadata.project_path}`,
          `  Tokens:    ${ctx.metadata.token_count.toLocaleString()} / ${budget.toLocaleString()} (${transferPct}% of target window)`,
          ``,
          `  Objective: ${ctx.conversation_summary.objective}`,
          ctx.conversation_summary.pending_tasks.length
            ? `  Pending:   ${ctx.conversation_summary.pending_tasks.join(", ")}`
            : null,
          ``,
          `Next step: open ${filename} in your project — the AI will read it automatically.`,
        ]
          .filter(l => l !== null)
          .join("\n");

        return { content: [{ type: "text", text: result }] };
      } catch (err: any) {
        return {
          content: [{ type: "text", text: `Error loading context: ${err.message}` }],
          isError: true,
        };
      }
    }
  );
}
